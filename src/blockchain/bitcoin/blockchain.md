---
title: 区块链原理
category:
  - 区块链
order: 1
---

# 区块链原理

## 什么是区块链?

区块链（英文名：blockchain或block chain）是一种块链式存储、不可篡改、安全可信的**去中心化**分布式账本，它结合了分布式存储、点对点传输、共识机制、密码学等技术，通过不断增长的数据块链（Blocks）记录交易和信息，确保数据的安全和透明性。

## 区块链的历史

区块链起源于比特币（Bitcoin），最初由中本聪（Satoshi Nakamoto）在2008年提出，作为比特币的底层技术。从诞生初期的比特币网络开始，区块链逐渐演化为一项全球性技术，吸引了全球的关注和投资。随后，以太坊（Ethereum）等新一代区块链平台的出现进一步扩展了应用领域 。

* [维基百科](https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BE)
* [百度百科](https://baike.baidu.com/item/%E5%8C%BA%E5%9D%97%E9%93%BE/13465666)

## 区块链的主要特性

1. **去中心化**

   * 区块链没有单一的中心机构，网络中的每个节点都可以参与记账与验证。
   * 避免了对单一第三方的依赖，降低了单点故障和被操纵的风险。

2. **不可篡改性**

   * 区块链数据一旦写入区块并被全网确认，就几乎无法更改。
   * 篡改某个区块的数据需要同时修改其后所有区块，并获得全网多数节点的认可，几乎不可能实现。

3. **可追溯性**

   * 每个区块都包含前一区块的哈希值，形成链式结构。
   * 交易信息全程可追溯，保证透明和可验证。

4. **公开透明**

   * 在公有链中，所有交易对所有节点公开，任何人都可以查看区块和交易记录。
   * 增强了系统的公信力。

5. **匿名性 / 假名性**

   * 用户通过公钥地址进行交易，而非真实身份。
   * 保持一定程度的隐私保护，但并非完全匿名。

6. **共识机制**

   * 区块链通过工作量证明（PoW）、权益证明（PoS）等机制来达成共识。
   * 确保在没有中心机构的情况下，节点能就交易达成统一结果。

7. **智能合约**（扩展特性）

   * 在以太坊等平台中，区块链支持智能合约。
   * 能够自动执行预设条件的合约条款，提升自动化和信任度。

---

## 区块链的数据结构

### 数据结构

**1. 整体结构**

区块链是由一系列区块按时间顺序链接而成的链式数据结构。每个区块都包含一批交易记录，并通过密码学[哈希函数](#哈希算法)与前一个区块连接。

**2. 区块结构**

每个区块主要包含两部分：

* 区块头（Block Header）：包含元数据
* 区块体（Block Body）：包含交易数据

**3. 区块头组成**

- 版本号（Version）：区块链协议版本
- 前一区块哈希（Previous Block Hash）：指向前一个区块
- 默克尔树根（Merkle Root）：当前区块所有交易的哈希摘要，它是[Merkle Root hash](#什么是merkle-hash)记录了本区块所有交易
- 时间戳（Timestamp）：区块创建时间
- 难度目标（Difficulty Target）：挖矿难度, 挖矿寻找一个随机数nonce，最终使得拼出来的整个区块头的哈希满足： $Hash(block \space header) \le target$
- 随机数（Nonce）：用于工作量证明

**4. 默克尔树结构**

默克尔树是一种二叉树结构，用于高效验证交易数据的完整性。叶子节点是交易哈希，非叶子节点是子节点哈希的组合哈希。

```
┌─────────────────────────┐       ┌─────────────────────────┐       ┌─────────────────────────┐
│        Block 10         │──────►│        Block 11         │──────►│        Block 12         │
├───────────┬─────────────┤       ├───────────┬─────────────┤       ├───────────┬─────────────┤
│ Prev_Hash │ Timestamp   │       │ Prev_Hash │ Timestamp   │       │ Prev_Hash │ Timestamp   │
├───────────┼─────────────┤       ├───────────┼─────────────┤       ├───────────┼─────────────┤
│ Tx_Root   │ Nonce       │       │ Tx_Root   │ Nonce       │       │ Tx_Root   │ Nonce       │
└───────────┴─────────────┘       └─────┬─────┴─────────────┘       └───────────┴─────────────┘
                                        │
                                        │
                              ┌─────────┴─────────┐
                              │                   │
                              ▼                   ▼
                          ┌────────┐         ┌────────┐
                          │ Hash01 │         │ Hash23 │
                          └───┬────┘         └────┬───┘
                              │                   │
                    ┌─────────┴─────────┐ ┌───────┴───────┐
                    │                   │ │               │
                    ▼                   ▼ ▼               ▼
                ┌───────┐           ┌───────┐         ┌───────┐         ┌───────┐
                │ Hash0 │           │ Hash1 │         │ Hash2 │         │ Hash3 │
                └───┬───┘           └───┬───┘         └───┬───┘         └───┬───┘
                    │                   │                 │                 │
                    ▼                   ▼                 ▼                 ▼
                ┌───────┐           ┌───────┐         ┌───────┐         ┌───────┐
                │  Tx0  │           │  Tx1  │         │  Tx2  │         │  Tx3  │
                └───────┘           └───────┘         └───────┘         └───────┘
```

### 比特币区块结构源代码介绍

```cpp
// 区块头（总大小：80 字节）
int32_t nVersion;         // 4 字节，区块版本号，用于升级
uint256 hashPrevBlock;    // 32 字节，前一个区块的哈希值（区块链的链式结构关键）
uint256 hashMerkleRoot;   // 32 字节，当前区块所有交易的 Merkle 树根哈希
uint32_t nTime;           // 4 字节，区块产生的时间戳（Unix 时间）
uint32_t nBits;           // 4 字节，难度目标的压缩表示
uint32_t nNonce;          // 4 字节，随机数，挖矿时不断变化以寻找合适哈希
```

> 来源于：[bitcoin](https://github.com/bitcoin/bitcoin/blob/master/src/primitives/block.h)

### 可视化数据展示

<iframe src="/ethereum/data_structure.html" width="100%" height="800"></iframe>


## 加密算法

### 非对称加密算法 （私钥、公钥）

* 一对两把密钥，分别用于加密、解密（公开、私有）
* RSA算法：大整数分解；ECC算法：椭圆曲线
* 破解228比特的RSA密钥需要的能量可煮沸一茶匙的水，而破解228比特的ECC密钥需要的能量能煮沸地球上所有的水

### 哈希算法

哈希算法 （默克尔树、区块指针、比特币挖矿），又称散列算法，它是一个单向函数，可以把任意长度的输入数据转化为固定长度的输出

```
h=H(x)
```

* 任意长度消息压缩成固定长度的二进制串
* SHA家族
  * SHA-1（已被攻破）、SHA-256（比特币）、SHA-384、SHA-512
* MD4/MD5（已被攻破）

#### 常见的哈希算法

| 哈希算法   | 输出长度 (bit) | 输出长度 (字节) |
| ---------- | -------------- | ---------------- |
| MD5        | 128 bit        | 16 bytes         |
| RipeMD160  | 160 bit        | 20 bytes         |
| SHA-1      | 160 bit        | 20 bytes         |
| SHA-256    | 256 bit        | 32 bytes         |
| SHA-512    | 512 bit        | 64 bytes         |


比特币使用两种哈希算法，一种是对数据进行两次SHA-256计算，这种算法在比特币协议中通常被称为hash256或者dhash。

另一种算法是先计算SHA-256，再计算RipeMD160，这种算法在比特币协议中通常被称为hash160。

:::tip

**例如，对morning和bitcoin两个输入进行某种哈希运算，得到的结果是固定长度的数字：**

H("morning") = c7c3169c21f1d92e9577871831d067c8
H("bitcoin") = cd5b1e4947e304476c788cd474fb579a
我们通常用十六进制表示哈希输出。

因为哈希算法是一个单向函数，要设计一个安全的哈希算法，就必须满足：通过输入可以很容易地计算输出，但是，反过来，通过输出无法反推输入，只能暴力穷举。

H("???????") = c7c3169c21f1d92e9577871831d067c8
H("???????") = cd5b1e4947e304476c788cd474fb579a

**2^256 是一个非常巨大的数字**

这个数字有多大呢？它大约有78位数字，比可观测宇宙中的原子数量（大约10^80）还要接近。
计算时间取决于具体任务：

**1.直接计算2^256的值：**

* 现代计算机可以瞬间完成（毫秒级）
* 大多数编程语言都有大整数库支持

**2.如果是暴力破解2^256种可能性：**

* 这是密码学中的安全级别
* 即使用全世界最快的超级计算机，也需要比宇宙年龄长得多的时间
* 大约需要 10^60 年以上
:::

### 哈希碰撞

#### 什么是哈希碰撞？

哈希函数（Hash Function）是一种将任意长度的输入数据映射为固定长度输出值的算法。

由于 输入无限，输出有限，必然存在两个不同的输入得到相同的哈希值的情况（碰撞概率低），这就是 哈希碰撞（Hash Collision）。

```伪代码
H("data-111111") = a76b1fb579a02a476c789d9115d4b201
H("data-AAAAAA") = a76b1fb579a02a476c789d9115d4b201
```

#### 为什么会发生哈希碰撞？

哈希函数的输出长度有限，例如：

- MD5 → 128 位输出
- SHA-1 → 160 位输出
- SHA-256 → 256 位输出

不同输入经过哈希函数可能映射到相同的输出值。

## 什么是Merkle Hash？

在区块链的区块头部，有一个重要的字段叫做**Merkle Hash**，它记录了该区块中所有交易的汇总哈希值。Merkle Hash是一种将多个数据的哈希值通过特定算法合并成单一汇总哈希的技术。

### Merkle Hash的计算原理

#### 基本计算流程

假设一个区块包含4个交易，Merkle Hash的计算步骤如下：

**第一步：计算每个交易的哈希值**
```
a1 = dhash(tx1)
a2 = dhash(tx2) 
a3 = dhash(tx3)
a4 = dhash(tx4)
```

**第二步：两两配对计算上层哈希**
```
b1 = dhash(a1 + a2)
b2 = dhash(a3 + a4)
```

**第三步：计算最终的Merkle Hash**
```
merkle = dhash(b1 + b2)
```

#### 可视化结构

```
                    ┌───────────────────┐
                    │merkle=dhash(b1+b2)│
                    └───────────────────┘
                              ▲
              ┌───────────────┴───────────────┐
              │                               │
      ┌───────────────┐               ┌───────────────┐
      │b1=dhash(a1+a2)│               │b2=dhash(a3+a4)│
      └───────────────┘               └───────────────┘
              ▲                               ▲
      ┌───────┴───────┐               ┌───────┴───────┐
      │               │               │               │
┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│a1=dhash(tx1)│ │a2=dhash(tx2)│ │a3=dhash(tx3)│ │a4=dhash(tx4)│
└─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘
```

### 处理奇数个交易的情况

#### 3个交易的处理方法

当交易数量不是2的幂次方时（如3个交易），需要对最后一个单独的哈希值进行复制：

```
                    ┌───────────────────┐
                    │merkle=dhash(b1+b2)│
                    └───────────────────┘
                              ▲
              ┌───────────────┴───────────────┐
              │                               │
      ┌───────────────┐               ┌───────────────┐
      │b1=dhash(a1+a2)│               │b2=dhash(a3+a3)│
      └───────────────┘               └───────────────┘
              ▲                               ▲
      ┌───────┴───────┐               ┌───────┴───────┐
      │               │               │               │
┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌ ─ ─ ─ ─ ─ ─ ┐
│a1=dhash(tx1)│ │a2=dhash(tx2)│ │a3=dhash(tx3)│ │   复制a3    │
└─────────────┘ └─────────────┘ └─────────────┘ └ ─ ─ ─ ─ ─ ─ ┘
```

#### 5个交易的处理方法

对于5个交易，需要在多个层级进行复制操作：

```
                      ┌─────────┐
                      │ merkle  │
                      └─────────┘
                           ▲
               ┌───────────┴───────────┐
               │                       │
             ┌───┐                   ┌───┐
             │c1 │                   │c2 │
             └───┘                   └───┘
               ▲                       ▲
         ┌─────┴─────┐           ┌─────┴─────┐
         │           │           │           │
       ┌───┐       ┌───┐       ┌───┐       ┌ ─ ┐
       │b1 │       │b2 │       │b3 │       │b3 │
       └───┘       └───┘       └───┘       └ ─ ┘
         ▲           ▲           ▲
     ┌──┴──┐     ┌──┴──┐     ┌──┴──┐
     │     │     │     │     │     │
   ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌ ─ ┐
   │a1 │ │a2 │ │a3 │ │a4 │ │a5 │ │a5 │
   └───┘ └───┘ └───┘ └───┘ └───┘ └ ─ ┘
```

### 核心规则总结

1. **配对原则**：从底层开始，将相邻的哈希值两两配对
2. **复制规则**：当某层出现奇数个哈希值时，复制最后一个哈希值
3. **递归计算**：重复上述过程直到得到唯一的根哈希值

### Merkle Hash的安全特性

Merkle Hash提供了强大的数据完整性保护：

- **防篡改**：修改任何一个交易的任意字节都会导致最终的Merkle Hash发生变化
- **防重排**：交换任意两个交易的顺序也会改变Merkle Hash的值
- **快速验证**：可以高效地验证某个交易是否存在于区块中

### 实际应用价值

在区块链系统中，Merkle Hash被记录在区块头部，发挥着关键作用：

1. **数据完整性保证**：确保区块中的交易记录无法被恶意修改
2. **高效验证**：支持轻节点快速验证交易而无需下载完整区块
3. **存储优化**：用单一哈希值代表整个交易集合，大幅减少存储需求

通过Merkle Hash机制，区块链实现了在分布式环境下对交易数据的可靠保护，这是区块链技术不可篡改特性的重要技术基础。

### 参考资料

[算法详细介绍](./appendix/mt.md)


## Block Hash

区块本身用Block Hash——也就是区块哈希来标识。但是，一个区块自己的区块哈希并没有记录在区块头部，而是通过计算区块头部的哈希得到的：

![](https://liaoxuefeng.com/books/blockchain/bitcoin/basic/block-hash.jpg)

区块头部的`Prev Hash`记录了上一个区块的`Block Hash`，这样，可以通过`Prev Hash`追踪到上一个区块。

由于下一个区块的`Prev Hash`又会指向当前区块，这样，每个区块的`Prev Hash`都指向自己的上一个区块，这些区块串起来就形成了区块链。

> 区块链的第一个区块（又称创世区块）并没有上一个区块，因此，它的`Prev Hash`被设置为00000000...000。

如果一个恶意的攻击者修改了一个区块中的某个交易，那么[Merkle hash](./appendix/mt.md)验证就不会通过。所以，他只能重新计算Merkle Hash，然后把区块头的Merkle Hash也修改了。这时，我们就会发现，这个区块本身的Block Hash就变了，所以，下一个区块指向它的链接就断掉了。

![Broken Chain](https://liaoxuefeng.com/books/blockchain/bitcoin/basic/broken-chain.jpg)

由于比特币区块的哈希必须满足一个难度值，因此，攻击者必须先重新计算这个区块的Block Hash，然后，再把后续所有区块全部重新计算并且伪造出来，才能够修改整个区块链。

在后面的挖矿中，我们会看到，修改一个区块的成本就已经非常非常高了，要修改后续所有区块，这个攻击者必须掌握全网51%以上的算力才行，所以，修改区块链的难度是非常非常大的，并且，由于正常的区块链在不断增长，同样一个区块，修改它的难度会随着时间的推移而不断增加。

