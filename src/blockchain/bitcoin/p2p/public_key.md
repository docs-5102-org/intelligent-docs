---
title: 公钥和地址
category:
  - 区块链
  - 公钥和地址
---

# 公钥和地址

## 1. 概述

比特币公钥是根据私钥通过椭圆曲线数字签名算法（ECDSA）计算得出的。私钥本质上是一个256位整数，记作k。通过ECDSA算法，可以从私钥推导出公钥，但无法从公钥反向推导出私钥，这保证了比特币系统的安全性。

## 2. 公钥生成原理

### 2.1 椭圆曲线基础

比特币使用[secp256k1](../../appendix/secp256k1.md)椭圆曲线，其数学公式为：

**y² = x³ + 7 (mod p)**

其中p是一个大质数：2²⁵⁶ - 2³² - 977

### 2.2 公钥计算

公钥生成过程遵循以下公式：

**公钥 = 私钥 × G**

这里G是椭圆曲线的基点（生成元），是secp256k1标准中定义的固定点。通过ECDSA算法，可以推导出两个256位整数，记作(x, y)，这两个256位整数即为非压缩格式的公钥。

## 3. 公钥格式

### 3.1 非压缩格式

- **长度**：65字节（520位）
- **格式**：`0x04` + x坐标（32字节）+ y坐标（32字节）
- **前缀**：`04`
- **特点**：包含完整的x和y坐标信息

### 3.2 压缩格式

- **长度**：33字节（264位）
- **格式**：前缀 + x坐标（32字节）
- **前缀**：
  - `02`：y坐标为偶数时
  - `03`：y坐标为奇数时
- **特点**：只保存x坐标，通过前缀标识y坐标的奇偶性

### 3.3 格式转换与选择

由于ECC曲线的特点，根据非压缩格式的公钥(x, y)的x实际上也可推算出y，但需要知道y的奇偶性。因此：

- 压缩格式和非压缩格式的公钥可以互相转换
- 两种格式均不可反向推导出私钥
- 压缩格式节省存储空间和传输带宽

目前比特币系统主要使用压缩格式的公钥，原因包括：
- 节省存储空间（33字节 vs 65字节）
- 减少交易数据大小
- 降低网络传输成本

### 3.4 代码实现示例

使用bitcoinjs-lib库从私钥生成公钥：

```javascript
const bitcoin = require('bitcoinjs-lib');

// 私钥（WIF格式）
let wif = 'KwdMAjGmerYanjeui5SHS7JkmpZvVipYvB2LJGU1ZxJwYvP98617';

// 导入私钥，创建ECPair对象
let ecPair = bitcoin.ECPair.fromWIF(wif);

// 计算公钥（默认返回压缩格式）
let pubKey = ecPair.getPublicKeyBuffer(); // 返回Buffer对象

// 输出压缩格式的公钥（02或03开头）
console.log(pubKey.toString('hex'));
```

## 4. 地址

### 4.1 地址概念

**重要提醒**：比特币的地址并不是公钥，而是公钥的哈希。从公钥能推导出地址，但从地址不能反推公钥，因为哈希函数是单向函数。

### 4.2 地址生成流程

比特币地址通过以下步骤从公钥生成：

1. **SHA256哈希**：对公钥进行SHA256哈希运算
2. **RIPEMD-160哈希**：对SHA256结果进行RIPEMD-160哈希（Hash160）
3. **添加版本前缀**：主网地址添加`0x00`前缀
4. **计算校验和**：对前面结果进行双重SHA256哈希，取前4字节作为校验和
5. **Base58Check编码**：使用Base58Check编码生成最终的比特币地址

### 4.3 地址结构

以压缩格式的公钥为例，地址生成过程如下：

```
0x00      hash160         check
┌─┬──────────────────────┬─────┐
│1│          20          │  4  │
└─┴──────────────────────┴─────┘
```

对上述25字节数据进行Base58编码，得到总是以`1`开头的字符串，该字符串即为比特币地址。

[compressed-address-flow.png](https://liaoxuefeng.com/books/blockchain/bitcoin/p2p/public-key/compressed-address.jpg)

### 4.4 地址生成代码示例

使用JavaScript实现公钥到地址的编码：

```javascript
const bitcoin = require('bitcoinjs-lib');

let publicKey = '02d0de0aaeaefad02b8bdc8a01a1b8b11c696bd3d66a2c5f10780d95b7df42645c';

// 从公钥创建ECPair对象（不包含私钥）
let ecPair = bitcoin.ECPair.fromPublicKeyBuffer(Buffer.from(publicKey, 'hex'));

// 计算地址
let address = ecPair.getAddress();
console.log(address); // 输出以1开头的地址
```

**注意**：计算地址时不必知道私钥，可以直接从公钥计算地址。

### 4.5 地址特性

- 以`1`开头的字符串地址即为比特币收款地址，可以安全地公开给任何人
- 对非压缩格式和压缩格式的公钥进行哈希编码得到的地址都以`1`开头
- 从地址本身无法区分使用的是压缩格式还是非压缩格式的公钥
- 仅提供地址并不能让其他人得知公钥
- 如果某个地址的资金被花费过至少一次，该地址的公钥实际上就公开了

## 5. 密钥体系关系图

私钥、公钥以及地址的推导关系如下：

```
┌───────────┐      ┌───────────┐
│Private Key│─────▶│Public Key │
└───────────┘      └───────────┘
      ▲                  │
      │                  │
      ▼                  ▼
┌───────────┐      ┌───────────┐
│    WIF    │      │  Address  │
└───────────┘      └───────────┘
```

## 6. 小结

1. **私钥到公钥**：基于椭圆曲线数学的单向变换
2. **公钥格式**：压缩格式（33字节）已成为主流选择
3. **地址生成**：公钥经过Hash160和Base58Check编码生成
4. **安全保证**：基于椭圆曲线离散对数问题和哈希函数的计算复杂性
5. **实际应用**：在比特币交易验证和资金管理中发挥核心作用
6. **隐私保护**：地址作为公钥哈希，提供了额外的隐私层

---

*注：本文档基于比特币协议的技术实现，涉及的密码学算法和数学原理为比特币系统安全性的理论基础。在实际开发中，建议使用成熟的加密库来处理相关计算。*
